# =============================================================================
# CONFIGURAÇÃO FUNCIONAL PARA LOGS MIKROTIK RB750GR3 (corrigida)
# =============================================================================

# ======================
# ENTRADA
# ======================
input {
  udp {
    host  => "0.0.0.0"
    port  => 514
    codec => "line"
    type => "mikrotik_firewall"
  }
}

# ======================
# FILTRO
# ======================
filter {
  if [type] == "mikrotik_firewall" {

    # (opcional) preserve a mensagem bruta para auditoria
    mutate { add_field => { "[event][original]" => "%{message}" } }

    # Identifica automaticamente o tópico do log
    grok {
      match => {
        "message" => [
          "^%{WORD:topic},%{WORD:severity}"
        ]
      }
      tag_on_failure => ["_topic_parse_failure"]
    }

    # Fallback para parsing do tópico
    if "_topic_parse_failure" in [tags] {
      if [message] =~ /^(\w+),(\w+)/ {
        grok { match => { "message" => "^%{WORD:topic},%{WORD:severity}" } }
      }
    }

    # Limpar severity duplicado (ex.: "warning,warning")
    if [severity] {
      mutate { gsub => ["severity", ",.*", ""] }
    }

    # ===== FIREWALL =====
    if [topic] == "firewall" {

      # Extrai IPs/portas (com e sem portas)
      grok {
        match => {
          "message" => [
            "%{IP:src_ip}:%{INT:src_port}->%{IP:dst_ip}:%{INT:dst_port}",
            "%{IP:src_ip}->%{IP:dst_ip}"
          ]
        }
        tag_on_failure => []
      }

      # Protocolo (grok único, mais eficiente; cobre 'proto x' e 'proto=x')
      grok {
        match => { "message" => "(?i)proto[ =]+%{DATA:protocol}" }
        tag_on_failure => []
      }

      # Interface
      grok {
        match => { "message" => "in:%{WORD:in_interface}" }
        tag_on_failure => []
      }

      # MAC
      grok {
        match => { "message" => "src-mac %{MAC:src_mac}" }
        tag_on_failure => []
      }

      # Classificação Drop / Evento
      if [message] =~ /Drop/ {
        mutate {
          add_field => {
            "priority"      => "high"
            "alert_type"    => "firewall_drop"
            "action"        => "Drop"
            "event_summary" => "Firewall Drop detectado"
          }
        }
      } else {
        mutate {
          add_field => {
            "priority"      => "medium"
            "alert_type"    => "firewall_event"
            "action"        => "Firewall"
            "event_summary" => "Evento de Firewall detectado"
          }
        }
      }
    }

    # ===== CRITICAL / SYSTEM / ERROR / WARNING =====
    if [topic] in ["critical", "system", "error", "warning"] {
      mutate {
        add_field => {
          "priority"   => "critical"
          "alert_type" => "system_alert"
          "action"     => "Alert"
        }
      }

      if [message] =~ /\[(.*?)\]/ {
        grok { match => { "message" => ".*?\[%{GREEDYDATA:event_details}\].*" } }
      }

      if [topic] == "system" {
        if [message] =~ /interface.*down/ or [message] =~ /interface.*up/ {
          mutate {
            add_field => {
              "alert_type"    => "interface_status"
              "event_summary" => "Mudança de status da interface"
            }
          }
        } else if [message] =~ /reboot|restart/ {
          mutate {
            add_field => {
              "alert_type"    => "system_reboot"
              "event_summary" => "Sistema reiniciado"
            }
          }
        }
      }

      if [topic] == "error" {
        mutate {
          add_field => {
            "alert_type"    => "system_error"
            "event_summary" => "Erro do sistema detectado"
          }
        }
      }

      if [topic] == "critical" {
        mutate {
          add_field => {
            "alert_type"    => "critical_alert"
            "event_summary" => "Alerta crítico do sistema"
          }
        }
      }

      if [topic] == "warning" {
        mutate {
          add_field => {
            "alert_type"    => "system_warning"
            "event_summary" => "Aviso do sistema"
          }
        }
      }
    }

    # ===== DNS =====
    if [topic] == "dns" {
      mutate {
        add_field => {
          "priority"      => "medium"
          "alert_type"    => "dns_event"
          "action"        => "DNS_Event"
          "event_summary" => "Evento de DNS detectado"
        }
      }
      if [message] =~ /query.*from/ {
        grok { match => { "message" => ".*query %{GREEDYDATA:dns_query} from %{IP:dns_client_ip}.*" } }
      }
    }

    # ===== INFO =====
    if [topic] == "info" {
      mutate {
        add_field => {
          "priority"      => "low"
          "alert_type"    => "info_event"
          "action"        => "Info"
          "event_summary" => "Informação do sistema"
        }
      }
    }

    # ===== Contexto temporal (JRuby-safe) =====
    ruby {
      code => '
        begin
          ts = event.get("@timestamp")
          t  = ts.time # Time em UTC
          hour = t.hour
          wday = t.wday
          if wday >= 1 && wday <= 5 && hour >= 11 && hour < 21  # ~08-18 BRT convertidos para UTC (UTC-3)
            event.set("[time_context][period]", "horario_comercial")
          else
            event.set("[time_context][period]", "fora_de_hora")
          end
          days = ["Domingo","Segunda-feira","Terça-feira","Quarta-feira","Quinta-feira","Sexta-feira","Sábado"]
          event.set("[time_context][day_of_week]", days[wday])
        rescue => e
          event.set("[ruby_error_time_context]", e.message)
        end
      '
      add_tag => ["time_context_added"]
    }

    # ===== Intervalo p/ drops =====
    if [topic] == "firewall" and [priority] == "high" and [action] == "Drop" and [alert_type] == "firewall_drop" {
      ruby {
        code => '
          begin
            ts = event.get("@timestamp")
            t  = ts.time
            minute = t.min
            second = t.sec
            interval_key = (second < 30) ? "#{minute}_0" : "#{minute}_30"
            event.set("interval_key", interval_key)
            event.set("interval_note", "Intervalo de 30s")
          rescue => e
            event.set("interval_key", "default")
            event.set("interval_note", "Erro no timestamp")
          end
        '
      }
    }
  }
}

# ======================
# SAÍDAS
# ======================
output {
  # ---------- Elasticsearch ----------
  elasticsearch {
    hosts       => ["http://elasticsearch:9200"]
    index       => "mikrotik-firewall-%{+YYYY.MM.dd}"
    action      => "index"      # mais seguro que "create"
    data_stream => false        # boolean (sem aspas)
  }

  # ---------- Telegram: críticos ----------
  if [topic] in ["critical", "system", "error", "warning"] and [priority] == "critical" {
    http {
      url          => "http://telegram_bridge:8080/notify"
      http_method  => "post"
      format       => "json"
      mapping => {
        "@timestamp"   => "%{@timestamp}"
        "host"         => "%{[host][ip]}"
        "topic"        => "%{topic}"
        "severity"     => "%{severity}"
        "action"       => "%{action}"
        "message"      => "%{event_summary}"
        "priority"     => "%{priority}"
        "alert_type"   => "%{alert_type}"
        "event_details"=> "%{event_details}"
        "note"         => "Log %{topic} - %{severity}"
        "time_context" => "%{[time_context][period]}"
        "day_of_week"  => "%{[time_context][day_of_week]}"
      }
    }
  }

  # ---------- Telegram: DNS ----------
  if [topic] == "dns" and [priority] == "medium" {
    http {
      url          => "http://telegram_bridge:8080/notify"
      http_method  => "post"
      format       => "json"
      mapping => {
        "@timestamp"   => "%{@timestamp}"
        "host"         => "%{[host][ip]}"
        "topic"        => "dns_event"
        "severity"     => "%{severity}"
        "action"       => "%{action}"
        "message"      => "%{event_summary}"
        "priority"     => "%{priority}"
        "alert_type"   => "%{alert_type}"
        "dns_query"    => "%{dns_query}"
        "dns_client_ip"=> "%{dns_client_ip}"
        "note"         => "Evento DNS detectado"
        "time_context" => "%{[time_context][period]}"
        "day_of_week"  => "%{[time_context][day_of_week]}"
      }
    }
  }

  # ---------- Telegram: drops de firewall ----------
  if [type] == "mikrotik_firewall" and [topic] == "firewall" and [priority] == "high" and [action] == "Drop" and [alert_type] == "firewall_drop" and [interval_key] {
    http {
      url           => "http://telegram_bridge:8080/notify"
      http_method   => "post"
      content_type  => "application/json"
      format        => "json"
      mapping => {
        "@timestamp"   => "%{@timestamp}"
        "host"         => "%{[host][ip]}"
        "topic"        => "firewall_drop"
        "severity"     => "%{severity}"
        "action"       => "%{action}"
        "proto"        => "%{protocol}"
        "srcip"        => "%{src_ip}"
        "srcport"      => "%{src_port}"
        "dstip"        => "%{dst_ip}"
        "dstport"      => "%{dst_port}"
        "message"      => "%{event_summary}"
        "priority"     => "%{priority}"
        "alert_type"   => "%{alert_type}"
        "src_mac"      => "%{src_mac}"
        "in_interface" => "%{in_interface}"
        "interval_key" => "%{interval_key}"
        "note"         => "%{interval_note}"
      }
    }
  }
}